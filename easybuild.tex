\easybuild{}~\cite{EasyBuildSC12} is a software build and installation framework
written in Python. Its primary goal is to alleviate user support teams from the
ubiquitous burden of getting scientific software built and installed~\cite{Dubois03}.

The \easybuild{} project was started in 2009 by the HPC-UGent team of Ghent
University (Belgium), out of frustration of the lack of appropriate tools for dealing
with scientific software installations. The first public release of \easybuild{} (version 0.5) was made available in April 2012, after it has been developed in-house for 
about 2.5 years. In November 2012, \easybuild{} v1.0 was released, featuring
a stable API. Since then the tool has been continuously enhanced and extended,
following a `release early, release often' strategy with a new major release every
4--6 weeks. To date, the latest release is \easybuild{} v1.14.0 (July 2014).

Under the motto ``\emph{building software with ease}", \easybuild{} provides an easy
yet powerful way to automatically install (scientific) software stacks, in a robust,
consistent and reproducible way. Its design is deliberately made very flexible and
modular (see Sections~\ref{sec:eb_configurability} and \ref{sec:eb_extensible})
making it an ideally suited platform for collaboration across HPC sites, as is
confirmed by the steadily growing \easybuild{} community (see
Section~\ref{sec:communities_synergy}).

\subsection{Concepts and design}

\easybuild{} consists of a collection of Python modules and packages that
interact with each other, dynamically picking up additional Python modules as needed
for building and installing a (stack of) software package(s) specified via simple
specification files. Or, in \easybuild{} terminology: the \easybuild{}
\emph{framework} leverages \emph{easyblocks} to build and install software using
a particular \emph{compiler toolchain}, as specified by one or multiple
\emph{easyconfig files}.

\subsubsection{\easybuild{} framework}
\label{sec:eb_framework}

The \easybuild{} \emph{framework} embodies the core of the tool,
providing functionality commonly need when installing scientific software on HPC
systems. For example, it deals with:
\begin{itemize}
    \item downloading, unpacking and patching software sources;
    \item loading environment modules for software dependencies;
    \item setting up the build enviroment, i.e, defining environment variables
    like \texttt{\$CC},
    \texttt{\$CXXFLAGS}, etc.;
    \item running shell commands (e.g., \texttt{make}), including running
    interactive commands autonomously;
    \item creating module files that match the specification files;
\end{itemize}

Included in the framework is an `abstract' implementation of a software build and
install procedure, which is split up into different \emph{steps}: unpacking sources,
configuration, build, installation, module generation, etc. Most of these steps, i.e.,
the ones that are generally more-or-less analogous across
different software packages, have appropriate (default) implementations. The only
exceptions are the configuration, build and installation steps that are purposely
left unimplemented (since there is no common procedure for them). Each of the steps
can be tweaked and steered via different parameters known to the framework, for
which values are either obtained from the provided specification files (see
Section~\ref{sec:eb_easyconfigs}) or set to reasonable default values.

In \easybuild{} v1.14.0 the framework source code consists of almost 30,000 lines
of code, properly organized across about 110 Python modules in roughly a dozen Python
package directories. This provides some notion of the size of the \easybuild{}
framework and the amount of supporting functionality it has to offer.

\subsubsection{Easyblocks}
\label{sec:eb_easyblocks}

The implementation of a particular software build and install procedure is done in
a Python module, which is aptly referred to as an `easyblock'. Each easyblock
ties in with the framework API by filling in (or extending/replacing) one or more of
the step functions that are defined in the abstract procedure used by the \easybuild{}
framework. Easyblocks typically heavily rely on the supporting functionality provided
by the framework, e.g., for running (interactive) shell commands and obtaining the output and exit code of the executed command, using the provided Python functions
\texttt{run\_cmd} or \texttt{run\_cmd\_qa}.

A distinction is made between \emph{software-specific} and \emph{generic} easyblocks.
Software-specific easyblocks implement a build and install procedure which is entirely
custom to one particular software package (e.g., WRF, OpenFOAM, etc.), while the
latter implements a procedure using standard tools (e.g., configuring with CMake and
building/installing via Makefiles, or configuring via environment variables, building
with \texttt{make} and installing by simply copying files to the installation
directory, etc.). Since easyblocks are implemented in an object-oriented scheme,
the steps implemented by various easyblocks can be reused in others via (multiple)
inheritance, enabling code reuse across implementations of build procedures.

For each software package being built, the \easybuild{} framework will determine
which easyblock should be used, based on the name of the software package or the
value of the \texttt{easyblock} specification parameter. In case an easyblock
specification is not provided and no (software-specific) easyblock matching the
software name could be found, a fallback mechanism will resort to using the generic
\texttt{ConfigureMake} easyblock, which implements the commonly used
\texttt{configure} -- \texttt{make} -- \texttt{make install} procedure.

At the time of writing, the most recent release of \easybuild{} included support for
(exactly) 500 different software packages, ranging from fairly simple tools and
libraries like gzip and zlib, over commonly used tools like GCC, various MPI
stacks (OpenMPI, MPICH2, MVAPICH, etc.) and math libraries (e.g., OpenBLAS,
FFTW), to large scientific software packages that are notorious for their involved
and painful install procedures, such as CP2K, NWChem, OpenFOAM, QuantumESPRESSO, and
WRF.

\subsubsection{Compiler toolchains}
\label{sec:eb_toolchains}

\easybuild{} also employs so-called `compiler toolchains' (or simply `toolchains'
for short), which were already mentioned in Section~\ref{sec:Module_naming_scheme}.
A toolchain consists of a (set of) compiler(s), usually together with a couple of
libraries for specific functionality, e.g., using an MPI stack for distributed
computing, or which provide optimized routines for commonly used math operations,
e.g., the well-known BLAS/LAPACK APIs for linear algebra routines. For each software
package being built, a toolchain must be specified that should be used
(see Section~\ref{sec:eb_easyconfigs}).

The \easybuild{} framework prepares the build environment for the different
toolchain components, by loading their respective modules and defining environment
variables to specify compiler commands (e.g., via \texttt{\$F90}), compiler and
linker options (e.g., via \texttt{\$CFLAGS} and \texttt{\$LDFLAGS}), the list of
library names to supply to the linker (via \texttt{\$LIBS}), etc. This enables
making easyblocks largely toolchain-agnostic since they can simply rely on these
environment variables; that is, unless they need to be aware of for example the
particular compiler being used to determine the build configuration options.

Recent releases of \easybuild{} include out-of-the-box support for the GCC, Intel,
Clang, and CUDA compilers, next to common MPI libraries such as Intel MPI, MPICH2,
MVAPICH2, and OpenMPI, various BLAS/LAPACK libraries including ATLAS, Intel MKL,
OpenBLAS, and ScaLAPACK, and libraries providing FFT routines like FFTW.

\subsubsection{Easyconfig files}
\label{sec:eb_easyconfigs}

The specification files that are supplied to \easybuild{} are referred to as
`easyconfig files' (or `easyconfigs' for short). These are basically plain text
files, containing (mostly) only key-value assignments for build parameters supported
by the framework (which are also referred to as `easyconfig parameters`). Some
parameters are mandatory, like \texttt{name} and \texttt{version} to specify which
(version of) software package should be installed, \texttt{toolchain} to indicate
which compiler toolchain should be used, etc. Others are optional, and have
appropriate defaults set for them in the \easybuild{} framework; examples include
\texttt{buildopts} to specify options for the build command, and \texttt{dependencies}
to list the software dependencies that should be taken into account. A complete
list of supported easyconfig parameters can be obtained using \texttt{eb -a}.

As such, each easyconfig file provides a complete specification of which particular
software package should be installed, and which settings should be using for building
it. \easybuild{} copies the used easyconfig file after completing an installation
to the install directory, and also supports maintaining an easyconfig archive which
is updated on every successful installation. Therefore, reproducing installations
becomes trivial.

\subsection{Basic usage}

As the name suggests, \easybuild{} is particularly easy to use. A command aptly named
\texttt{eb} is provided to interact with the \easybuild{} framework, which accepts
the usual \texttt{--help} command line option yielding a summary of all supported
command line options.

Launching \texttt{eb} with an easyconfig file as an argument triggers a
series of events. First, the easyconfig file will be parsed by the \easybuild{}
framework to determine which software package needs to be installed, and which
easyblock and parameters should be used. Afterwards, the environment is prepared by
loading the modules for the specified toolchain and dependencies, if those are
available, and the toolchain support in the framework defines the additional
environment variables as discussed in Section~\ref{sec:eb_toolchains}. If the
required modules are not available, an appropriate error message is shown, unless
the dependency resolution mechanism is enabled via \texttt{--robot} (see
Section~\ref{sec:eb_dependency_resolution} for more details). Next,
the appropriate build and install procedure is executed step by step, as defined by
the framework and selected easyblock. Finally, a module is generated, that is if the
installation is successful, a module file is generated that matches the used
specifications in terms of module name and contents.

For example, the following command instructs \easybuild{} to install WRF v3.5
with the \texttt{goolf} toolchain v1.6.10, as specified by the provided easyconfig
file:

\texttt{eb WRF-3.5-goolf-1.6.10.eb}

Further details on using \texttt{eb} are beyond the scope of this paper; we refer
to \texttt{eb --help} and the \easybuild{} wiki~\cite{ebwiki} for extensive
documentation.

\subsection{Feature highlights}
\label{sec:eb_features}

We now briefly highlight a couple of key features of \easybuild{}, which are relevant
to the topic of this paper, including automatically resolving dependencies and
the flexibility of the \easybuild{} framework. Other noteworthy features which are
not discussed here include, but are not limited to, thorough logging of the build
and install process, support for tweaking provided easyconfig files directly from
the \texttt{eb} command line, and off-loading individual \easybuild{} invocations to
a (PBS) resource manager.

\subsubsection{Automatic dependency resolution}
\label{sec:eb_dependency_resolution}

\easybuild{} supports installing a entire software stack, including the required
toolchain if needed, with a single \texttt{eb} invocation. By using the
\texttt{--robot} command line option the dependency resolution mechanism will
construct a full dependency graph for the software package(s) being installed, after
which a list of dependencies is composed for which no module is available yet. Each of
the retained dependencies will then be built and installed, in the required order as
indicated by the dependency graph(s). This is particularly useful for software
packages that have an extensive list of dependencies, or when reinstalling software
using a different compiler toolchain.

\subsubsection{Configurability}
\label{sec:eb_configurability}

Allowing users to modify \easybuild{}'s default behavior to their needs is another
important feature. \easybuild{} can be configured in three different ways: via one or
more configuration files, via environment variables prefixed with
\texttt{EASYBUILD\_}, and via command line options. For each command line option a
matching environment variable can be set, and matching parameter can be defined in an
configuration file. Command line options overrule environment variables, while they
in turn overrule configuration files, resulting in an intuitive and flexible yet
powerful way of controlling \easybuild{}'s behavior. Configuration parameters
are available for straightforward aspects such as the installation prefix for
software and module files, but also for example the log level, modules tool and
module naming scheme that should be used. A full overview of the available
configuration parameters can be consulted via \texttt{eb --help}.

\subsubsection{Dynamic extensibility}
\label{sec:eb_extensible}

Another key feature is that \easybuild{} can be extended dynamically, i.e., the
framework is designed such that additional functionality can be simply plugged in:
additional easyblocks, support for more compilers and libraries to be part
of a toolchain, custom module naming schemes, etc. Extending \easybuild{} is done by
implementing a Python module in the required namespace (e.g.,
\texttt{easybuild.easyblocks}), and modifying the \texttt{\$PYHONPATH} environment
variable to make sure that it is available in the Python search path at runtime.
Every time \texttt{eb} is used, the framework will `scan' the Python search path to
determine the available options for each of the dynamically extendible aspects.
This provides \easybuild{} users the freedom to experiment with functionality which
is not (yet) available in the particular version they're using, or to extend
the supported options for different aspects of \easybuild{} with site-specific
options, e.g., easyblocks for in-house software packages or a custom module naming
scheme.

\subsection{Support for hierarchical module naming schemes}

Since \easybuild{}~v1.14.0, sufficiently fine-grained control of the active module
naming scheme is available, thus allowing to implement and use a custom `hierarchical`
module naming scheme. As discussed in Section~\ref{sec:eb_features}, it suffices to
implement the specific details of the hierarchical module naming scheme in a Python
module, which must live in the \texttt{easybuild.tools.module\_naming\_scheme}
namespace. In particular, the Python module must provide a Python class that derives
from the `abstract' \texttt{ModuleNamingScheme} class provided by the \easybuild{}
framework, and define a couple of method that cover different aspects of the
module naming scheme. For example the \texttt{det\_modpath\_extensions} method must
return a list of strings representing \texttt{\$MODULEPATH} extensions, given a
parsed easyconfig file as an argument. This is a simple yet powerful approach,
providing full control over all particular aspects of the module naming scheme.
With this in place, \easybuild{} must be configured to use this particular module
naming scheme, see also Section~\ref{sec:eb_configurability}.

Letting \easybuild{} automatically generate module files under a specified
(hierarchical) module naming scheme stands in stark contrast with the practice of
manually creating module files and trying to apply site policies. It avoids the
various issues involved with manually creating module files w.r.t. consistency and
correctness which were disscussed in Section~\ref{sec:traditional}, and as such mostly
relieves user support teams from another tedious task related to installing
scientific software.
