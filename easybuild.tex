\easybuild{}~\cite{EasyBuildSC12} is a software build and installation framework
written in Python. Its primary goal is to alleviate user support teams from the
ubiquitous burden of getting scientific software built and installed~\cite{Dubois03}.

The \easybuild{} project was started in 2009 by the HPC-UGent team of Ghent
University (Belgium), out of frustration of the lack of appropriate tools for dealing
with scientific software installations. The first public release of \easybuild{} (version 0.5) was made available in April 2012, after it has been developed in-house for 
about 2.5 years. In November 2012, \easybuild{} v1.0 was released, featuring
a stable API. Since then the tool has been continuously enhanced and extended,
following a `release early, release often' strategy with a new major release every
4--6 weeks. To date, the latest release is \easybuild{} v1.14.0 (July 2014).

Under the motto ``\emph{building software with ease}", \easybuild{} provides an easy
yet powerful way to automatically install (scientific) software stacks, in a robust,
consistent and reproducible way. Its design is deliberately made very flexible and
modular (see Sections~\ref{sec:eb_flexible} and \ref{sec:eb_extensible}) making it
an ideally suited platform for collaboration across HPC sites, as is confirmed by
the steadily growing \easybuild{} community (see
Section~\ref{sec:communities_synergy}).

\subsection{Concepts and design}

\easybuild{} consists of a collection of Python modules and packages that
interact with each other, dynamically picking up additional Python modules as needed
for building and installing a (stack of) software package(s) specified via simple
specification files. Or, in \easybuild{} terminology: the \easybuild{}
\emph{framework} leverages \emph{easyblocks} to build and install software using
a particular \emph{compiler toolchain}, as specified by one or multiple
\emph{easyconfig files}.

\subsubsection{\easybuild{} framework}
\label{sec:eb_framework}

The \easybuild{} \emph{framework} embodies the core of the tool,
providing functionality commonly need when installing scientific software on HPC
systems. For example, it deals with:
\begin{itemize}
    \item downloading, unpacking and patching software sources;
    \item setting up the build enviroment,  e.g., loading environment modules for
    the software dependencies, defining environment variable like \texttt{\$CC},
    \texttt{\$CXXFLAGS}, \texttt{\$LDFLAGS} and \texttt{\$LIBS}, etc.;
    \item running shell commands (e.g., \texttt{make}), including running
    interactive commands autonomously;
    \item creating module files that match the specification files;
    \item etc.
\end{itemize}

Included in the framework is an `abstract' implementation of a software build and
install procedure, which is split up into different \emph{steps}: unpacking sources,
configuration, build, installation, module generation, etc. Most of these steps, i.e.,
the ones that are generally more-or-less analogous across
different software packages, have appropriate (default) implementations. The only
exceptions are the configuration, build and installation steps that are purposely
left unimplemented (since there is no common procedure for them). Each of the steps
can be tweaked and steered via different parameters known to the framework, for
which values are either obtained from the provided specification files (see
Section~\ref{sec:eb_easyconfigs}) or set to reasonable default values.

In \easybuild{} v1.14.0 the framework source code consists of almost 30,000 lines
of code, properly organized across about 110 Python modules in roughly a dozen Python
package directories. This provides some notion of the size of the \easybuild{}
framework and the amount of supporting functionality it has to offer.

\subsubsection{Easyblocks}
\label{sec:eb_easyblocks}

The implementation of a particular software build and install procedure is done in
a Python module, which is aptly referred to as an `easyblock'. Each easyblock
ties in with the framework API by filling in (or extending/replacing) one or more of
the step functions that are defined in the abstract procedure used by the \easybuild{}
framework. Easyblocks typically heavily rely on the supporting functionality provided
by the framework, e.g., for running (interactive) shell commands and obtaining the output and exit code of the executed command, using the provided Python functions
\texttt{run\_cmd} or \texttt{run\_cmd\_qa}.

A distinction is made between \emph{software-specific} and \emph{generic} easyblocks.
Software-specific easyblocks implement a build and install procedure which is entirely
custom to one particular software package (e.g., WRF, OpenFOAM, etc.), while the
latter implements a procedure using standard tools (e.g., configuring with CMake and
building/installing via Makefiles, or configuring via environment variables, building
with \texttt{make} and installing by simply copying files to the installation
directory, etc.). Since easyblocks are implemented in an object-oriented scheme,
the steps implemented by various easyblocks can be reused in others via (multiple)
inheritance, enabling code reuse across implementations of build procedures.

For each software package being built, the \easybuild{} framework will determine
which easyblock should be used, based on the name of the software package or the
value of the \texttt{easyblock} specification parameter. In case an easyblock
specification is not provided and no (software-specific) easyblock matching the
software name could be found, a fallback mechanism will resort to using the generic
\texttt{ConfigureMake} easyblock, which implements the commonly used
\texttt{configure} -- \texttt{make} -- \texttt{make install} procedure.

At the time of writing, the most recent release of \easybuild{} included support for
(exactly) 500 different software packages, ranging from fairly simple tools and
libraries like gzip and zlib, over commonly used tools like GCC, various MPI
stacks (OpenMPI, MPICH2, MVAPICH, etc.) and math libraries (e.g., OpenBLAS,
FFTW), to large scientific software packages that are notorious for their involved
and painful install procedures, such as CP2K, NWChem, OpenFOAM, QuantumESPRESSO, and
WRF.

\subsubsection{Easyconfig files}
\label{sec:eb_easyconfigs}

\subsubsection{Compiler toolchains}


\subsection{Basic functionality}

automatic download/configure/build/install/module

\remark{include figure showing schematic representation of easyconfig, easyblock, framework relation}


\subsection{Feature highlights}

\subsubsection{Automatic dependency resolution}

\subsubsection{Flexibility}
\label{sec:eb_flexible}

configuration, module naming scheme,

\subsubsection{Dynamic extensibility}
\label{sec:eb_extensible}

easyblocks, toolchains, module naming scheme


\subsection{Support for hierarchical module naming scheme}

Since EasyBuild v1.14.0 ...


\subsection{\easybuild{} as a platform for collaboration}

community-driven, capture expertise,
