\easybuild{}~\cite{EasyBuildSC12} is a software build and installation framework
written in Python. Its primary goal is to alleviate user support teams from the
ubiquitous burden of getting scientific software built and installed~\cite{Dubois03}.

The \easybuild{} project was started in 2009 by the HPC-UGent team of Ghent
University (Belgium), out of frustration of the lack of appropriate tools for dealing
with scientific software installations. The first public release of \easybuild{} (version 0.5) was made available in April 2012, after it has been developed in-house for 
about 2.5 years. In November 2012, \easybuild{} v1.0 was released, featuring
a stable API. Since then the tool has been continuously enhanced and extended,
following a `release early, release often' strategy with a new major release every
4--6 weeks. To date, the latest release is \easybuild{} v1.14.0 (July 2014).

Under the motto ``\emph{building software with ease}", \easybuild{} provides an easy
yet powerful way to automatically install (scientific) software stacks, in a robust,
consistent and reproducible way. Its design is deliberately made very flexible and
modular (see Sections~\ref{sec:eb_flexible} and \ref{sec:eb_extensible}) making it
an ideally suited platform for collaboration across HPC sites, as is confirmed by
the steadily growing \easybuild{} community (see
Section~\ref{sec:communities_synergy}).

\subsection{Concepts and design}

\easybuild{} consists of a collection of Python modules and packages that
interact with each other, dynamically picking up additional Python modules as needed
for building and installing a (stack of) software package(s) specified via simple
specification files. Or, in \easybuild{} terminology: the \easybuild{}
\emph{framework} leverages \emph{easyblocks} to build and install software using
a particular \emph{compiler toolchain}, as specified by one or multiple
\emph{easyconfig files}.

\subsubsection{\easybuild{} framework}
\label{sec:eb_framework}

The \easybuild{} \emph{framework} embodies the core of the tool,
providing functionality commonly need when installing scientific software on HPC
systems. For example, it deals with:
\begin{itemize}
    \item downloading, unpacking and patching software sources;
    \item loading environment modules for software dependencies;
    \item setting up the build enviroment, i.e, defining environment variables
    like \texttt{\$CC},
    \texttt{\$CXXFLAGS}, etc.;
    \item running shell commands (e.g., \texttt{make}), including running
    interactive commands autonomously;
    \item creating module files that match the specification files;
\end{itemize}

Included in the framework is an `abstract' implementation of a software build and
install procedure, which is split up into different \emph{steps}: unpacking sources,
configuration, build, installation, module generation, etc. Most of these steps, i.e.,
the ones that are generally more-or-less analogous across
different software packages, have appropriate (default) implementations. The only
exceptions are the configuration, build and installation steps that are purposely
left unimplemented (since there is no common procedure for them). Each of the steps
can be tweaked and steered via different parameters known to the framework, for
which values are either obtained from the provided specification files (see
Section~\ref{sec:eb_easyconfigs}) or set to reasonable default values.

In \easybuild{} v1.14.0 the framework source code consists of almost 30,000 lines
of code, properly organized across about 110 Python modules in roughly a dozen Python
package directories. This provides some notion of the size of the \easybuild{}
framework and the amount of supporting functionality it has to offer.

\subsubsection{Easyblocks}
\label{sec:eb_easyblocks}

The implementation of a particular software build and install procedure is done in
a Python module, which is aptly referred to as an `easyblock'. Each easyblock
ties in with the framework API by filling in (or extending/replacing) one or more of
the step functions that are defined in the abstract procedure used by the \easybuild{}
framework. Easyblocks typically heavily rely on the supporting functionality provided
by the framework, e.g., for running (interactive) shell commands and obtaining the output and exit code of the executed command, using the provided Python functions
\texttt{run\_cmd} or \texttt{run\_cmd\_qa}.

A distinction is made between \emph{software-specific} and \emph{generic} easyblocks.
Software-specific easyblocks implement a build and install procedure which is entirely
custom to one particular software package (e.g., WRF, OpenFOAM, etc.), while the
latter implements a procedure using standard tools (e.g., configuring with CMake and
building/installing via Makefiles, or configuring via environment variables, building
with \texttt{make} and installing by simply copying files to the installation
directory, etc.). Since easyblocks are implemented in an object-oriented scheme,
the steps implemented by various easyblocks can be reused in others via (multiple)
inheritance, enabling code reuse across implementations of build procedures.

For each software package being built, the \easybuild{} framework will determine
which easyblock should be used, based on the name of the software package or the
value of the \texttt{easyblock} specification parameter. In case an easyblock
specification is not provided and no (software-specific) easyblock matching the
software name could be found, a fallback mechanism will resort to using the generic
\texttt{ConfigureMake} easyblock, which implements the commonly used
\texttt{configure} -- \texttt{make} -- \texttt{make install} procedure.

At the time of writing, the most recent release of \easybuild{} included support for
(exactly) 500 different software packages, ranging from fairly simple tools and
libraries like gzip and zlib, over commonly used tools like GCC, various MPI
stacks (OpenMPI, MPICH2, MVAPICH, etc.) and math libraries (e.g., OpenBLAS,
FFTW), to large scientific software packages that are notorious for their involved
and painful install procedures, such as CP2K, NWChem, OpenFOAM, QuantumESPRESSO, and
WRF.

\subsubsection{Compiler toolchains}

\easybuild{} also employs so-called `compiler toolchains' (or simply `toolchains'
for short), which were already mentioned in Section~\ref{sec:Module_naming_scheme}.
A toolchain consists of a (set of) compiler(s), usually together with a couple of
libraries for specific functionality, e.g., using an MPI stack for distributed
computing, or which provide optimized routines for commonly used math operations,
e.g., the well-known BLAS/LAPACK APIs for linear algebra routines. For each software
package being built, a toolchain must be specified that should be used
(see Section~\ref{sec:eb_easyconfigs}).

The \easybuild{} framework prepares the build environment for the different
toolchain components, by loading their respective modules and defining environment
variables to specify compiler commands (e.g., via \texttt{\$F90}), compiler and
linker options (e.g., via \texttt{\$CFLAGS} and \texttt{\$LDFLAGS}), the list of
library names to supply to the linker (via \texttt{\$LIBS}), etc. This enables
making easyblocks largely toolchain-agnostic since they can simply rely on these
environment variables; that is, unless they need to be aware of for example the
particular compiler being used to determine the build configuration options.

Recent releases of \easybuild{} include out-of-the-box support for the GCC, Intel,
Clang, and CUDA compilers, next to common MPI libraries such as Intel MPI, MPICH2,
MVAPICH2, and OpenMPI, various BLAS/LAPACK libraries including ATLAS, Intel MKL,
OpenBLAS, and ScaLAPACK, and libraries providing FFT routines like FFTW.

\subsubsection{Easyconfig files}
\label{sec:eb_easyconfigs}

The specification files that are supplied to \easybuild{} are referred to as
`easyconfig files' (or `easyconfigs' for short). These are basically plain text
files, containing (mostly) only key-value assignments for build parameters supported
by the framework (which are also referred to as `easyconfig parameters`). Some
parameters are mandatory, like \texttt{name} and \texttt{version} to specify which
(version of) software package should be installed, \texttt{toolchain} to indicate
which compiler toolchain should be used, etc. Others are optional, and have
appropriate defaults set for them in the \easybuild{} framework; examples include
\texttt{buildopts} to specify options for the build command, and \texttt{dependencies}
to list the software dependencies that should be taken into account.

As such, each easyconfig file provides a complete specification of which particular
software package should be installed, and which settings should be using for building
it. \easybuild{} copies the used easyconfig file after completing an installation
to the install directory, and also supports maintaining an easyconfig archive which
is updated on every successful installation. Therefore, reproducing installations
becomes trivial (see also Section~\ref{sec:eb_reproducability}).


\subsection{Basic functionality}

As the name suggests, \easybuild{} is particularly easy to use. It provides

automatic download/configure/build/install/module

\remark{include figure showing schematic representation of easyconfig, easyblock, framework relation}


\subsection{Feature highlights}

\subsubsection{Support for reproducible software installations}
\label{sec:eb_reproducability}

\subsubsection{Automatic dependency resolution}

\subsubsection{Flexibility}
\label{sec:eb_flexible}

configuration, module naming scheme,

\subsubsection{Dynamic extensibility}
\label{sec:eb_extensible}

easyblocks, toolchains, module naming scheme


\subsection{Support for hierarchical module naming scheme}

Since EasyBuild v1.14.0 ...


\subsection{\easybuild{} as a platform for collaboration}

community-driven, capture expertise,
