Although the latest versions of both \easybuild{} and Lmod already provide
flexible support for hierarchical module naming schemes, further enhancements can
be made to extend the capabilities and improve the user experience. We discuss
a couple of these which were not resolved yet at the time of writing.

The latest available version of \easybuild{} to date only supports generating
module files in Tcl syntax, while module files in Lua syntax are required to use
some of the advanced features that Lmod supports, e.g., defining properties and
families. This particular feature is already being implemented by members of the
\easybuild{} community.

Although the required support is available, a deeper module hierarchy that
better matches the toolchain concept in \easybuild{} should be worked out.
Usually, only the \texttt{Compiler} and \texttt{MPI} hierarchy levels are used,
while \easybuild{} toolchains can also include math libraries. Extending
the two-level hierarchy to capture this aspect is not straightforward however,
since BLAS/LAPACK/FFT functionality can be provided by one single library (e.g.,
Intel MKL), or by multiple distinct libraries (e.g., OpenBLAS, LAPACK and FFTW).
This complicates the design of a deeper hierarchy that supports swapping one
math library for one or multiple others providing the same functionality.

Related to this the more generic concept of a `multi-dimensional' module hierarchy,
also referred to as a module `matrix', is currently an area of active research.
In such a multi-dimensional module hierarchy, the notion of a module that would
only become available when \emph{multiple} other modules are loaded together can be
supported. This is interesting for software packages that provide support for using
different libraries for some particular functionality, like the parallel
solver library PETSc which supports different LAPACK/FFT libraries. For example,
in such a module hierarchy, a module for PETSc would not be available until modules
for both e.g. OpenBLAS \emph{and} FFTW have been loaded. On top of this, it should
also support swapping out the loaded modules for OpenBLAS and FFTW for one single
module providing equivalent functionality, e.g., an Intel MKL module, and trigger a
reload of the PETSc module. Supporting this would be particularly useful for
application developers, and for benchmarking studies.

Another improvement to \easybuild{} would be making the dependency resolution
mechanism aware of subtoolchains. When \texttt{eb} checks the availability of
modules that match the required dependencies, it uses the toolchain selected
for the software being installed (unless this is overridden specifically on a
per-dependency basis). This requires that modules which are, for example, only
dependent on a compiler are built and installed multiple times with different
toolchains, even though they are providing the same software builds. This yields
more modules than required and consumes additional disk space. Also checking for
modules that were installed with a compatible subtoolchain, providing for example
only the compiler, enables that these tools only need to be installed once.

Mixing environment modules installed with different naming schemes leads to problems,
especially when both flat and hierarchical module naming schemes are being used.
Therefore, migrating to a hierarchically organized set of modules may be painful.
To enable a smooth transition, a separate module tree with a different layout
can be set up where users can gradually opt into.
This requires that \easybuild{} supports generating multiple module files for a
single software installation under different naming schemes. Only (re)generating a
module file for an existing software installation should also be made possible, so an
alternative module stack can be populated without having to reinstall all available
software.

\ignore{
Furthermore, both \easybuild{} and Lmod need to be evaluated on, and possibly
ported to, special-purpose systems like Cray and IBM BlueGene. Preliminary
experiments are promising since they only reveal mostly minor issues on these
type of systems. On Cray systems for example, some care has to be taken in order
to be able to use the provided \texttt{ProgEnv} modules that wrap around the
different readily available compilers. One concept that is currently not well
supported yet by \easybuild{} is cross-compilation, in which software is built
for a particular type of system which is different than the one of which the build
is performed. This significantly complicates the running of tests, as is often
done by build configuration scripts.
\remark{mostly irrelevant to the paper topic}
}

%\markus{Future work: generate lua modulefiles from \easybuild{} including
%family specifications to prevent loading two compiler modules at the same
%time?}
