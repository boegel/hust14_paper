
\remark{this section should outline the modern approach of using a hierarchical module naming scheme,
highlighting how this makes things easier for end-users without limiting power users; forward references should
be made to the EasyBuild \& Lmod sections when the consequences of using a module naming scheme like this are discussed}

A solution to the common pitfalls that users run into when setting up their
working environment using modules (see Section~\ref{sec:issues_traditional})
is using a so-called \emph{hierarchical module naming scheme}, in which the
module files are organized in a more structured way.  The key idea behind 
this is to make module files only available in a step-by-step fashion.  That
is, initially only a small number of so-called \emph{core} modules are
available to the user.

Core modules are modules which are independent of a particular compiler
toolchain, that is, they are either completely self-contained or only
dependent on basic system software. Examples include module files for
compilers and statically linked software (e.g., debuggers).

These core modules (implicitly) extend the module search path
(\texttt{\$MODULEPATH}) to make additional modules visible, for example
the ones which are built with---and therefore depend on---the corresponding
compiler. As such, separate software installation and module files
subdirectories are maintained for each version of each compiler. For the
Open\,MPI example presented in Section~\ref{sec:Module_files}, this means
that the user then only sees a single module file for Open\,MPI 1.7.3 instead
of three: the one providing the installation built using the compiler module
that is currently loaded:

{\small
\begin{alltt}
    \textbf{% module avail}
    ------------ <\emph{prefix}>/Core ------------
    GCC/4.8.2   Intel/14.0  Clang/3.4
    \textbf{% module load GCC/4.8.2}
    \textbf{% module avail}
    ----- <\emph{prefix}>/Core -----
    ------------ <\emph{prefix}>/Core ------------
    GCC/4.8.2   Intel/14.0  Clang/3.4
    ----- <\emph{prefix}>/Compiler/GCC/4.8.2 -----
    OpenMPI/1.7.3
\end{alltt}
}


Obviously, such a hierarchy is not limited to a single level. For example,
the module files for different MPI implementations can further extend
\texttt{\$MODULEPATH} to enable all modules which depend on both the loaded
compiler and the respective MPI library.


\label{sec:hierarchical_advantages}
\subsection{Advantages over traditional module naming schemes}

\markus{This sub-subsection IMHO only makes sense if there would be a second
one. I propose to remove it and simply list the advantages as part of Section
III.A.}

Using a hierarchical module naming scheme has multiple important
advantages. First, at any point in time, users are only presented with the
modules which are meaningful in the current context. That is, the list of
available modules is much shorter and grouped by level of the hierarchy,
and therefore a lot less overwhelming when tens to hundreds of modules are
available (which is often the case on HPC systems that have been in
production for a while).

Second, encoding the dependency chain in the module name is no longer
necessary, since this can be encoded in the subdirectory that serves as a
extension to
\texttt{\$MODULEPATH}. This leads to significantly shorter and more intuitive
module names, usually consisting of the software name and version, e.g.,
\texttt{WRF/3.5} rather than the long and cryptic module names shown in
Section~\ref{sec:Module_files}.

Third, loading of incompatible
modules is automatically avoided, preventing users from making simple
mistakes which may lead to subtle errors that are non-obvious and hard to
debug. Not only does this enable a better user experience, it also avoids
that user support teams have to spend time on resolving tickets related
to issues caused by incompatible modules being loaded together.

Finally, the more structural organization of module files can be exploited
to provide new possibilities, a major one being supporting \emph{swapping}
out a loaded module on a particular level of the hierarchy with another
(e.g., a compiler module), while automatically reloading any module depending
on the previously loaded module. This notion needs to be supported be the
modules tool used to consume the module files however (see also
Section~\ref{sec:hierarchical_consequences}).

%\remark{basic users make less mistakes, expert users retain full freedom}

\label{sec:hierarchical_consequences}
\subsection{Consequences of using a hierarchical naming scheme}

Although the commonly used Tcl/C and Tcl-only environment modules tools
both support the concept of hierarchical modules (since they're mostly
oblivious to how the module files are structured), a couple of consequences
to using a hierarchical module naming scheme need to be taken into account.

\label{sec:hierarchical_consequences_visibility}
\subsubsection{Visibility of modules}
First of all, not all existing module files are visible by default, since
a particular core module and potentially additional lower-level modules
that further extend the module search path may need to be loaded first.
Although users can rely on standard Unix tools as for example `find`, this
is an important aspect that needs to be dealt with. Since the modules that
users may be interested in, i.e., the ones for the scientific software
packages they care about, are not listed in the output of \texttt{module
avail}, another way of quering the set of existing module files (outside
of the currently active \texttt{\$MODULEPATH}) needs to be
provided.

\label{sec:hierarchical_consequences_extensions}
\subsubsection{Awareness of module path extensions}
Second, the modules tool needs to be aware of the module path extensions that
may occur when loading modules in a hierarchical scheme. This is of
particular importance for supporting the notion of automatically reloading
dependent modules after swapping modules on one of the hierarchy level.
Basically, the modules tool needs to be able to i) detect that a particular
module depends on the module being swapped out, or in other words on which
level of the hierarchy each module lives, and ii) to unload the dependent
modules whenever a \texttt{module swap} is being executed, and afterwards
automatically (try to) reload the unloaded modules, meanwhile taking into
account the order in which the modules were loaded.

\label{sec:hierarchical_consequences_availability}
\subsubsection{Module availability on different paths in the hierarchy}
On top of this, the modules tool needs to take into account that it is
possible that not all dependent modules are available after swapping e.g.
one compiler module for another. This is required to avoid that the user
ends up with a hopelessly broken environment that got stuck somewhere in
between the original state before initiating the swap and the goal state
in which the alternative module and all its dependent module are loaded.
When such a situation occurs, the module tool should simply notify the user
that certain dependent modules could not be reloaded. If the modules tool
can somehow keep track of which modules failed to reload during a
\texttt{module swap}, the user-friendly possibility to revert the swap
operation could be supported as well, e.g. by making sure that the reverse
swap operation (\texttt{module swap B A} after a \texttt{module swap A B}
restores the original state of the environment.

% moved to lmod.tex

%Finally, \remark{saved collections to set default compiler/MPI to avoid that
%novice users need to pick a compiler/MPI stack before they can get anything
%done}
%\kenneth{Robert: does this make sense to include it? or is this not
%related enough to a hierarchical scheme?}
%\robert{I would remove from Finally ... to here.  It is a mixing of
%  concepts. At TACC we provide a default set of modules which the user
%  can override with their own personal collection of modules}

None of these issues are taken into account in the latest versions of the
Tcl/C and Tcl-only implementations of environment modules. At some point,
the notion of reloading depedent modules after a \texttt{module swap}
\emph{was} supported by the Tcl-only implementation, but this change was
undone again later on because it led to incompatible behavior between
these two versions.
However, the previously mentioned alternative modules tool Lmod does
provide all the necessary functionality (and more) to deal with each of
these issues, see Section~\ref{sec:lmod}.

%\markus{Somewhere, we should mention that the hierarchical module scheme as
%outlined above \textit{in principle} also works with C/Tcl or Tcl-only
%modules, but that specific features simplify usage a lot: ``stack-based'' swap,
%module deactivation, \texttt{module spider}, etc. But there is a small
%chicken/egg problem here \ldots}

\kenneth{below is still todo, to make \easybuild{} stand out a bit more}
\remark{complicates (manual) creation of module files due to hierarchical organization}
\easybuild{} (section~\ref{sec:easybuild}) automates creation of module files under a specified naming scheme;
