%\remark{this section should outline the modern approach of using a hierarchical module naming scheme,
%highlighting how this makes things easier for end-users without limiting power users; forward references should
%be made to the EasyBuild \& Lmod sections when the consequences of using a module naming scheme like this are discussed}

The use of \emph{hierarchical naming schemes} is an excellent way to
help users avoid the pitfalls described above. This approach
makes it possible to organize module files in a more structured
way. The key idea is to make module files available in a step-by-step fashion as
their dependencies become part of the user environment.  Initially only a small
number of so-called \emph{core} modules are available to the user.
Core modules are those that do not depend on software choices available
to the user; they are either completely self-contained or depend only on basic system software. Examples include module files for
compilers, and statically linked software like debuggers.

These core modules extend the module search path
(\texttt{\small \$MODULEPATH}) when loaded to make additional modules visible, for
example the ones which are built with---and therefore depend on---the currently loaded
compiler. Separate sub-directories for each version of each 
compiler store the software and module files that depend on
that compiler. For the
Open\,MPI example presented in Section~\ref{sec:Module_naming_scheme}, this means
that the user sees only the module for OpenMPI 1.7.3 that depends
the current compiler of choice.

{\small
\begin{alltt}
    \textbf{% module avail}
    ------------ \emph{<prefix>}/Core ------------
    GCC/4.8.2   Intel/14.0  Clang/3.4
    \textbf{% module load GCC/4.8.2}
    \textbf{% module avail}
    ------------ \emph{<prefix>}/Core ------------
    GCC/4.8.2   Intel/14.0  Clang/3.4
    ----- <\emph{prefix}>/Compiler/GCC/4.8.2 -----
    OpenMPI/1.7.3
\end{alltt}
}
\noindent
Such a hierarchy is not limited to a single level. The
module files for each MPI implementation, for example, can further extend
\texttt{\small \$MODULEPATH} to make the module visible that depend on the currently loaded compiler and MPI stack.


\subsection{Advantages over traditional module naming schemes}
\label{sec:hierarchical_advantages}

%\markus{This sub-subsection IMHO only makes sense if there would be a second
%one. I propose to remove it and simply list the advantages as part of Section
%III.A.}

Using a hierarchical module naming scheme has a number of important
advantages. First, at any point in time, users see only the
modules which are meaningful in the current context. That is, the list of
available modules is much shorter and grouped by level of the hierarchy. This is easier for users to process when hundreds of modules are
provided (which is generally the case on large HPC systems).

Second, encoding the dependency chain in the module name is no longer
necessary. This leads to significantly shorter and more intuitive
module names, usually consisting of the software name and version, e.g.,
\texttt{\small WRF/3.5} instead of the long and cryptic module names shown in
Section~\ref{sec:Module_naming_scheme}.

Third, loading incompatible
modules is no longer possible, which eliminates a broad class of subtle errors that
are difficult to debug. This not only dramatically improves the user experience; it
also significantly reduces the time a user support team needs to spend on related
problems.

Finally, this structured organization of module files provides
a number of new opportunities to enhance the user experience. One significant
example is module \emph{swapping}: when the user chooses a new compiler or MPI
stack by executing a command like \texttt{\small module swap gcc intel}, the module
system could (and should!) automatically replace lower-level modules with new
versions compatible with the user's new higher level selections. We strongly believe
that this capability should be part of any robust module system; see
Section~\ref{sec:using_a_hierarchy}.

%\remark{basic users make less mistakes, expert users retain full freedom}

\subsection{Using a hierarchical module naming scheme}
\label{sec:using_a_hierarchy}

In theory, the commonly used Tcl/C and Tcl-only environment modules tools both
support the concept of hierarchical modules; this is because these tools function
in a way that is essentially independent of any particular choice in organizing the
module files. In practice, this presents some difficulties when using these tool
with a software hierarchy.

\subsubsection{Visibility of modules}
\label{sec:hierarchical_consequences_visibility}

In the hierarchical scheme we describe above, a module is not available (visible)
to the user until that module's dependencies are part of the user environment.  This
is by design, and has great advantages. But a module system should not leave to the
user the burden of locating needed modules within a complicated directory structure. 
Instead, the module system should provide a built-in, natural mechanism for exposing 
hierarchies and dependencies, and make it possible for users to load needed modules
without resorting to raw searches of the system's directory structure. In particular,
the module system must provide a means for displaying relevant information about
modules that are outside the currently defined \texttt{\small \$MODULEPATH}.


\subsubsection{Awareness of module path extensions}
\label{sec:hierarchical_consequences_extensions}

Second, the modules tool needs to be aware of the module path extensions that
may occur when loading modules in a hierarchical scheme. This is of
particular importance for supporting the notion of automatically reloading
dependent modules after swapping modules on one of the hierarchy levels.
Basically, the modules tool needs to be able to i) detect that a particular
module depends on the module being swapped out, or in other words on which
level of the hierarchy each module lives, and ii) to unload the dependent
modules whenever a \texttt{\small module swap} is being executed, and afterwards
automatically (try to) reload them, meanwhile taking into
account the order in which the modules were loaded.

\subsubsection{Module availability on different paths in the hierarchy}
\label{sec:hierarchical_consequences_availability}

On top of this, the modules tool needs to take into account that it is
possible that not all dependent modules are available after swapping for example
one compiler module for another. This is required to avoid that the user
ends up with a hopelessly broken environment by getting stuck somewhere in
between the original state before initiating the swap and the goal state
in which the alternative module and all its dependent modules are (re)loaded.
When such a situation occurs, the module tool should simply notify the user
that certain dependent modules could not be reloaded. If the modules tool
can somehow keep track of which modules failed to reload during a
\texttt{\small module swap}, the user-friendly option to revert the swap
operation could be supported as well, e.g., by making sure that the reverse
swap operation (i.e., \texttt{\small module swap B A} after a
\texttt{\small module swap A B}) restores the original state of the environment.

None of these issues are taken into account in the latest versions of the
Tcl/C and Tcl-only implementations of the environment modules tools. At some point,
the notion of reloading depedent modules after a \texttt{\small module swap}
\emph{was} supported by the Tcl-only implementation, but this change was
reverted later on because it led to incompatible behavior between
these two versions which was deemed undesirable.

% moved to lmod.tex

%Finally, \remark{saved collections to set default compiler/MPI to avoid that
%novice users need to pick a compiler/MPI stack before they can get anything
%done}
%\kenneth{Robert: does this make sense to include it? or is this not
%related enough to a hierarchical scheme?}
%\robert{I would remove from Finally ... to here.  It is a mixing of
%  concepts. At TACC we provide a default set of modules which the user
%  can override with their own personal collection of modules}

%\markus{Somewhere, we should mention that the hierarchical module scheme as
%outlined above \textit{in principle} also works with C/Tcl or Tcl-only
%modules, but that specific features simplify usage a lot: ``stack-based'' swap,
%module deactivation, \texttt{module spider}, etc. But there is a small
%chicken/egg problem here \ldots}

\subsection{Maintaining a module hierarchy}
\label{sec:maintaining_a_hierarchy}

Next to the peculiarities with using a hierarchical module naming scheme discussed in
the previous section that need to be taken into account, maintaining a module stack
that is organized hierarchically is also more involved for user support teams
compared to a simple `flat' module naming scheme.

In particular, significantly more care has to taken when creating
module files. For one, the module path extensions that are included in modules
on the different levels of the hierarchy make it less straightforward to compose
module files. Determining the location of module files also becomes
non-trivial, since the dependencies of the software package being dealt with need
to be taken into account. Next to this, the \texttt{\small module load} statements
included in module files for these dependencies need to be determined carefully, to
ensure that unloading and swapping of modules doesn't yield unexpected results.
Modules in a hierarchical scheme \emph{must} be referred to using the name they will 
be exposed under to users, i.e. using their `short` name (e.g.,
\texttt{\small WRF/3.5}) relative to the \texttt{\small \$MODULEPATH} after loading
a core module and (potentially) other modules further extending the \texttt{\small
\$MODULEPATH}, rather than their `full' name relative to the top of the hierarchy
(e.g., \texttt{\small MPI/GCC/4.8.2/OpenMPI/1.7.3/WRF/3.5}).

All these aspects significantly complicate the manual creation of module files, which
is already a tedious task because of consistency requirements and the usual problems
like dependency tracking, etc. Combining these concerns with the time-consuming
nature of the prerequisite of `just' getting the scientific software installed
further highlights the indispensable need of an appropriate and flexible tool to
\emph{automate} installing scientific software on HPC systems.

\subsection{Tools}
\label{sec:tools_for_hierarchical}

The issues discussed in Sections~\ref{sec:using_a_hierarchy} and
\ref{sec:maintaining_a_hierarchy} clearly motivate the need for more advanced tools.
In the remainder of this paper, we present how the community-driven tools
\easybuild{}, a software build and installation framework, and Lmod, a modern
alternative to the environment modules tools, have the flexibility and required
features (and more) for efficiently dealing with a hierarchical module naming scheme,
see Sections~\ref{sec:easybuild} and \ref{sec:lmod} respectively.
