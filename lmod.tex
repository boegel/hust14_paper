Lmod~\cite{laytonLmod,taccSecretSauce,taccLmod} is a modern
replacement for environment modules.  With rare exceptions it is a
drop in replacement for Tcl/C modules. It can consume modulefiles
written in Tcl as well as Lua\cite{LuaBook}.  It has strong focus on
providing users easy access to their software stack, without hindering
experts.

The original idea for Lmod was to prototype a module system to test
ideas about how to handle a hierarchical module system.  It was clear
at the beginning that it was going to require a complete rewrite of
the system, so the Lua language was choosen because of clean yet
powerful constructs.  Lua also fills the same niche that Tcl was
originally designed for, namely, it embeds and extends easily into
other programs.  As time went on, it was clear that the Lmod modules
system written in Lua implementation was fast enough to use directly.

Since February of 2011, there have been 153 tagged version and 30+ official
releases of Lmod. THe latest available version to date is Lmod v5.7.3.

\subsection{Support for hierarchical module naming schemes}

The key idea that Lmod exploits is that it watches changes to
\texttt{\$MODULEPATH}. As such, it supports the advanced notion of
swapping modules in a hierarchical layout from the ground up, and thus
deals with the issues described in
Sections~\ref{sec:hierarchical_consequences_extensions} and
\ref{sec:hierarchical_consequences_availability}.

In a hierarchical layout, a compiler modulefile adds to
MODULEPATH a new directory of compatible modules.  Similarly an MPI
implementation's modulefile will add a directory for the compatible
parallel libraries and parallel applications that work with that
compiler and MPI pairing.

For example, swapping one (core) compiler module for another will trigger
a chain of events.  First, the old compiler module is unloaded
which causes the MPI and parallel packages that depend on it to be
nloaded because the respective module files can no longer be found.
These modules are marked \emph{inactive}.

Next, the new compiler module is loaded.  This means that a new entry
is added to the \texttt{\$MODULEPATH}, which will trigger a search
for compatible modules in the new module search path for each of the
inactive modules.

For example, swapping the loaded \emph{gcc} compiler module for the (default)
\emph{clang} module results in reloading the loaded module for the
\emph{fftw3} a parallel fft library and the \emph{mpich} MPI stack:
{\small
  \begin{alltt}
    \textbf{\% module list}
    Currently loaded modules:
    1) gcc/4.8.2  2) mpich/3.1.1  3) fftw3/3.3.2
    \textbf{\% module swap gcc clang}
    The following have been reloaded:
    1) fftw3/3.3.2  2) mpich/3.1.1
    \textbf{\% module list}
    Currently loaded modules:
    1) clang/3.4  2) mpich/3.1.1  3) fftw3/3.3.2
\end{alltt}
}
\noindent
To ease testing the list of module reloaded are printed out
alphabetically. Each ``\texttt{module list}'' command shows the
order in which the modules are loaded.

% \kenneth{does the order of the reloaded modules make sense? shouldn't
%   MPICH be reloaded first, since PETSc depends on it?}

Another key issue with a hierarchical layout of modules is that not all
existing modules are visible via \texttt{module avail} (see
Section~\ref{sec:hierarchical_consequences_visibility}). Lmod defines a
new command, \texttt{module spider}, to search for modules across the
entire module tree and report all \emph{existing} modules. The semantics of
the \texttt{module avail} command, i.e., reporting all modules that can
be \emph{loaded} in the current context (determined by
\texttt{\$MODULEPATH}) is retained, for compatibility with other module
tools.

This ability to maintain a consistent set of modules when coupled with a
hierarchical module layout, and navigating the module tree outside of the
current \texttt{\$MODULEPATH} is the key strength of Lmod, but there are
many more features.  Many of these have been implemented in response to
requests by the members of the Lmod community.

\subsection{\texttt{ml} shorthand}

Lmod provides a short-hand to those who misspell the \texttt{moduel}, \texttt{mdoule}, \emph{err}
\texttt{module} command.  It is common to want a list of the currently loaded
modules or load a new module.  So Lmod provides a command named
\texttt{ml}.  With no arguments, \texttt{ml} is the same as
\texttt{module list}, and \texttt{ml} \emph{X} is the same as \texttt{module
  load} \emph{X}.  When used with a leading minus a single command can
swap compilers and mpi stacks:
{\small
  \begin{alltt}
      \textbf{\% ml -gcc -mpich clang openmpi}
  \end{alltt}
}
\noindent
Is the same as:
{\small
  \begin{alltt}
      \textbf{\% module swap gcc clang}
      \textbf{\% module swap mpich openmpi}
  \end{alltt}
}

\texttt{ml} accepts other subcommands just like \texttt{module} does,
i.e. \texttt{ml avail} and \texttt{module avail} are equivalent.  If a
module name is the same as a module command does require a little
finessing.  So trying to load the spider modulefile has to be written
as \texttt{ml load spider}.

%\remark{needs to be fleshed out}

\subsection{Properties}

The module system is a key interface between users and system
administrators.
%For sites that use Modules systems,  it is how users
%access the software that they need to get their work done.
As the computer systems change so too do the requirements on the module
system.  One of these adding properties to modules.  Many
supercomputers now have one or more accelerators currently either GPU's
or XEON Phi's also known as MIC's.   In particular, XEON Phi's are a
daughter card across the PCI bus and to create applications to run on
the XEON Phi's requires cross compilation.  This means that libraries
are needed for the Phi's.  Due to the way the environment variables
are handled, a single modulefile can serve regular and Phi libraries.

But user's won't know which libraries are Phi-aware.  Lmod added
functions so that properties could be added to modulefiles.  This way
when modules are listed via module list, and avail the properties can
be reported.
{\small
\begin{alltt}
  \textbf{\% module list}
  Currently Loaded Modules:
    1) intel/14.0.2       3) mpich/3.1.2
    2) mkl/mkl      \textbf{(*)}   4) boost/1.55.0 \textbf{(P)}

  Where:
   \textbf{(*)}:  Supports host, native and offload
   \textbf{(P)}:  built for host and native Phi
\end{alltt}
}
\noindent
This shows the the intel mkl library and the C++ boost libraries are Phi-aware.
This is just one use of properties.  It is under site
control what properties are reported.  For example, some sites use it
to mark alpha and beta releases of software packages.
%\kenneth{include an example output, use bold face rather than a color for Phi-aware modules?}

\subsection{Caching}

Added support for properties added a complication to the module
system.  Without properties, the avail command just needed the name of
the module not the contents.  With properties, the contents of every
module needed to be read and evaluated, whether the modulefile had
properties or not. On parallel filesystems such as lustre this can be
slow.  To mitigate this, Lmod added the ability to have cache files.
It turns out that reading one large file is much faster than walking a
directory tree and reading several small files.  There is support for
both user and system cache files.  Keeping the cache files current can
be a challenge when installed software is being updated.  One approach
is to have the installing software system recomputes the cache after
completing the system update or the cache file is updated frequently
and hooks are in-place to know when the cache file is valid or not.

One of upshots of this is that Lmod trusts the cache files for
everything except for loading a modulefile.  This way a module can be
loaded even if the cache is out-of-date.  This can happen while
installing software (e.g. for \easybuild{}) but users will see an updated
cache file.

%\kenneth{also mention system vs user cache?}
%\robert{I don't know}

\subsection{Module families}

One of the improvements to Lmod is that there is the family function.
The way this works is that a compiler or mpi stack can be marked to be
part of a family and you only get one member of the family loaded at
one time.  It is possible to override this for the few expert user who
wish to have two compilers loaded at the same time.

{\small\begin{alltt}  \textbf{\% module load gcc}
  Lmod has detected the following error:
  You can only have one compiler module loaded.
  To correct this, please do the following:

  \textbf{\% module swap intel gcc/4.8.1}\end{alltt}}
\noindent
Users wanting to load two compilers can set the environment variable
\texttt{LMOD\_EXPERT}. to bypass this check.



%\kenneth{example of error message when loading two modules of the same family? mention how experts can override this exactly}

\subsection{Hooks}

Another key feature is the ability for sites to create a
\texttt{SitePackage.lua} file to modify the behavior of Lmod to suit
their needs.  Lmod provides ``hook'' functions that site can add
functionality.  There is a load hook.  This means that
every time a module is loaded a call to syslog can be
made to record a modules use.  Data from syslog can be collected to
know what modules are being used or not.

\subsection{Sensible version ordering}

There have been many improvement to improve usability for both users
and staff.  One of these is sensible version ordering.  Originally all
module systems use lexicological ordering.  This means that version
9.0 is considered newer than 10.0.  Now Lmod knows that version 10.0 $>$
9.7.1 $>$ 9.7 $>$ 9.7rc1 $>$ 9.7a2 and so on.  It knows about
numerical order in any of the digits so 1.10.12 $>$ 1.10.9 $>$ 1.9.10 $>$ 1.9.2
and so on.

%\kenneth{mention version since when Lmod support sensible version ordering, and maybe flesh out the example a bit more? you can use EasyBuild v1.9.10 vs v1.10.0 as an example ;-)}

\subsection{\texttt{pushenv}: stack-based setting of environment variables}
\label{sec:lmod_pushenv}

The module system
has supported \texttt{setenv} function which sets an environment variable
upon load a module and clears its value upon unload.  There are times
when users and administrators would like the previous value recovered
rather than cleared.  This is what \texttt{pushenv} does.  It
maintains a hidden stack in the environment so it can recover old
values.

Suppose the gcc module defines \texttt{\$CC} to be \texttt{gcc} and the mpich module
defines \texttt{\$CC} to \texttt{mpicc}.  The following table shows the value of
\texttt{\$CC} depending on whether \texttt{pushenv} or \texttt{setenv} is used:
\begin{center}
 \begin{tabular}{c|l|l|l}
 nr & command                                 & \texttt{setenv} & \texttt{pushenv}\\
 \hline
 1 & \textbf{\texttt{module load   gcc}}   & \texttt{gcc}    & \texttt{gcc}  \\
 2 & \textbf{\texttt{module load   mpich}} & \texttt{mpicc}  & \texttt{mpicc} \\
 3 & \textbf{\texttt{module unload mpich}} & \emph{(none)}   & \texttt{gcc}  \\
 4 & \textbf{\texttt{module unload gcc}}   & \emph{(none)}   & \emph{(none)} \\
  \hline
    \end{tabular}
\end{center}
\noindent
After command 1 and 2 the value of \texttt{CC} is the same.  It is the unload
with command 3 where the behavior changes.  With \texttt{setenv} \texttt{\$CC} is unset
whereas with \texttt{pushenv} recovers the previous value of
\texttt{gcc} in the third command.

%\kenneth{include an example of the effect of using \texttt{pushenv} rather than \texttt{setenv}, maybe using \texttt{\$CC}?}

\subsection{Module collections}

Sites can provide a default set of modules that includes a
compiler/MPI stack so that novice users will have something initially
to work with.  With Lmod, user can build a collection of modules
appropriate for them which they can mark as the set of modules they
want every time they log-in.  They can also have as many named
collection of modules as they like.


%\kenneth{try and give a rough idea of the size of the Lmod community?}

%\subsection{Key features}
%
%\begin{itemize}
%    \item user-friendly
%    \begin{itemize}
%        \item ml
%        \item sensible version ordering
%        \item case-insensitive module avail
%        \item module load => swap if needed
%        \item recursive unload (is default)
%        \item spider cache => fast avail (\& spider)
%    \end{itemize}
%    \item hooks
%    \item path priorities
%    \item properties
%    \item families
%    \item load with version range
%    \item pushenv
%\end{itemize}
%\remark{too long a list to include all? AP Robert: which ones do we really need to mention?}
%\remark{module swap works}
%\remark{module avail vs module spider}
%\remark{(spider cache)}
