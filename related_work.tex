We are aware of a number of projects similar to \easybuild{}.

\emph{SWTools}~\cite{swtools, jones08} is an ``infrastructure for software
management" which was developed by National Center for Computational Sciences (NCCS)
and Oak Ridge National Lab (ORNL). It defines a structure for organizing a set of
(bash) scripts per supported software package, one per major installation step
(configuration, build, test, installation, etc.), allowing for easily reproducing 
software installations. It also takes care of generating module files, and is
able to update documentation listing the available software packages.
Only one version is publicly available, SWTools v1.0, which was released Jan.~1st 2011.

\emph{Smithy}~\cite{smithy} is a follow-up to SWTools, and is also being developed
at NCCS/ORNL. It is compatible with the SWTools infrastructure and hence can be
used as a drop-in replacement, but also supports an alternative approach using
\emph{formulas} following the well-established \emph{Homebrew}~\cite{homebrew} package
management system for Mac~OS~X. As such, it provides
supporting functionality readily available to be used in these formulas, and enables
code reuse across formulas. Smithy is publicly available alongside detailed
documentation. The development activity has slowed down significantly since
Sept.~2013, with occasional changes mostly focusing on bug fixes.
Smithy formulas are available for about 80 software
packages.

Another related project is the \emph{iVEC Build System (iBS)}, which is developed 
by iVEC in Australia. Similarly to \easybuild{}
it consists of a framework providing (some) commonly needed functionality, which
picks up so-called ``iBS files" that implement the install procedure for a 
particular software package. Both the main command (aptly named
\texttt{\small ibs}) and the iBS files are bash scripts, the latter being sourced by
the former as needed. At the time of writing iBS was not publicly available yet, but
the developers are known to be working towards a public release.

Finally, \emph{Spack (Supercomputing PACKage Manager)}~\cite{spack} is another
tool, written in Python, that is similar to \easybuild{} with respect to functionality and
goals. It provides a powerful and well-documented command line interface giving
control over which dependencies, software versions, compiler, architecture and
various options should be used for installing a particular software package.
Spack also supports some particularly useful options like automatically determining
whether an update for a particular software package is available
(by scraping the project's website), automatically completing
incomplete build specifications, optional/virtual dependencies, etc. Like
\easybuild{}, the Python codebase is object-oriented, enabling code reuse and
efficient maintainability; the \emph{packages} concept in it is quite similar to
easyblocks in \easybuild{}. At the time of writing, Spack included support for about
50 different software packages.

\markus{@Kenneth: One reviewer expressed severe concerns w.r.t. to the
following paragraph. Do you see a chance to mitigate (at least some) of the
statements?}\kenneth{fixed, reworded to 'configurable' instead of 'flexible',
which is more correct}
\easybuild{} differs from these tools in a number of ways. First and foremost, it is
more configurable than any of the other tools. Although they provide some support
for configuring their behavior, there is no control over certain aspects like, for example, the
module naming scheme being used. Second, several useful more advanced
features are missing in most of them, like automatic dependency resolution (Spack
being the exception here). Third, exactly reproducing previous installations is more
difficult since most of these tools do not employ separate specification files (again,
except for Spack); through easyconfig files this is particularly easy with \easybuild{} however.
Fourth, none of these tools has been able to get a sizable community going, which
has significant implications with respect to user contributions and the number of supported
software packages.
Other issues only apply to some of them, e.g., limited code
maintainability and reuse of code (SWTools and iBS), public availability of recent
versions (SWTools and iBS), and a lack of active development (SWTools and Smithy).

To the best of our knowledge, no recent module tools other than Lmod and the commonly
used Tcl-based tools discussed in Section~\ref{sec:env_modules_system} are
available. There are some alternative tools with comparable functionality, however.
Dotkit~\cite{dotkit} is a tool that supports loading and unloading package description 
files in a similar fashion to modules. Softenv~\cite{softenv} also provides similar
functionality, but uses a monolithic database to provide the package description data.
Both tools use a flat layout, however, making them incompatible with the concept of a
hierarchical naming scheme. Neither tool is widely used at HPC sites as
opposed to the environment modules system. On top of this, both projects are no longer
actively developed, with latest versions being made available in Aug.~2008 and
Mar.~2007, respectively.

Several HPC sites have been using a hierarchical module naming scheme for years,
including TACC~\cite{lmodSC11}, the Arctic University of Norway, the University
of Michigan, Calcul Qu\'ebec, and the University of Florida. Most of these also provide
Lmod to their users, but we are unaware of any sites using both \easybuild{} and Lmod
for efficiently handling software installations in a hierarchical context on
production systems. However, some
sites are actively looking into potentially applying such a methodology in the
foreseeable future, including HPC-UGent, the J\"ulich Supercomputing Centre, and
Stanford University.
