In this section, we describe common approaches that are traditionally used at
HPC sites to install scientific software and to deal with the growing number
of modules over the lifetime of an HPC system. We start our discussion with a
brief overview of the concept of module files and various module naming
schemes which are in use today, followed by a description of the underlying
module tools used by most sites. Next, we review commonly used workflows for
installing scientific software and finally summarize the shortcomings we have
identified with these approaches.

\subsection{Tools \& policies}

\subsubsection{Module files}
\label{sec:Module_files}

In essence, module files are a textual description of what needs to be
changed in the user's environment to make a particular software package
available. Such changes may include the adjustment of environment variables
such as \texttt{PATH} or setting additional package-specific variables, for
example, convenience variables pointing to the include and/or library paths.
In addition, module files typically include a brief one-line description of
the package displayed by \texttt{module whatis} as well as a longer help text
printed by \texttt{module help} to describe the basic usage, where to find
the package documentation, and whom to contact in case of usage problems
(this may be the site's application support team or the developers of the
package directly).

Module files are recursively searched for in directories specified by the
environment variable \texttt{MODULEPATH}. The name of a module is defined
as the full path to the corresponding module file, starting from the
specified search directory. For example, the module file located in
\begin{verbatim}
    <searchdir>/compiler/GCC/4.8.2
\end{verbatim}
provides a module for version 4.8.2 of the GNU Compiler Collection with the
name `\texttt{compiler/GCC/4.8.2}'.

The example above also shows one possible way to categorize modules by
placing their module files into appropriately named subdirectories (e.g.,
`\texttt{compiler}', `\texttt{mpi}', `\texttt{math}', etc.). Another common
option is to list the individual subdirectories in \texttt{MODULEPATH}, so
that the module names are shorter, but the modules are still nicely separated
in the output of module avail, for example:
\begin{verbatim}
    % module avail
    -------- <searchdir>/compiler --------
    GCC/4.8.2   Intel/14.0  Clang/3.4
    ---------- <searchdir>/mpi -----------
    OpenMPI/1.7.3 MVAPICH/1.9
\end{verbatim}

However, since packages such as MPI implementations are inherently tied to a
particular compiler and most often even a particular version, disambiguating
module names can be a daunting task. For example, for the three compilers
shown above, the corresponding Open\,MPI modules are often named as follows:
\begin{verbatim}
    OpenMPI/1.7.3-GCC-4.8.2
    OpenMPI/1.7.3-Intel-14.0
    OpenMPI/1.7.3-Clang-3.4
\end{verbatim}

Now considering a full-blown scientific software package like WRF compiled
with a particular compiler and linked against a particular MPI, module names
get even messier, for example:
\begin{verbatim}
    WRF/3.5-GCC-4.8.2-OpenMPI-1.7.3
\end{verbatim}
Note that such packages in many cases also depend on a set of mathematical
libraries, such as BLAS+ScaLAPACK+FFTW vs. ACML vs. Intel MKL, which in a
real scenario extends the module name even further.

A common solution to this issue is to define so-called \emph{toolchain}
modules, packaging a compiler, an MPI library, and one or more packages
providing linear algebra and FFT functionality. For example, a \texttt{goolf}
toolchain module may combine (i.e., implicitly load modules for) GCC,
Open\,MPI, OpenBLAS, ScaLAPACK and FFTW---each with a well-defined version. The
WRF module as shown above may the simply refer to a toolchain instead of the
individual packages:
\begin{verbatim}
    WRF/3.5-goolf-1.6.10
\end{verbatim}
The toolchain concept also offers the possibility to categorize modules by
toolchain, however, if a software package is availabel for multiple
toolchains, it will then show up in multiple sections of the \texttt{module
avail} output. The downside of using toolchains, however, is that users have
to be taught what is hidden behind the often rather cryptic toolchain names
and that a toolchain version has no direct relationship with the versions of
the encapsulated packages.

It should be pointed out that altough all of the approaches to name and
categorize module files presented above try to improve the overall
organization of the available modules, a typical module listing on an HPC
system can still be overwhelming, as the total number of modules can easily
be in the order of hundreds. Moreover, all traditional aproaches offer a
multitude of options for (especially novice) users to shoot themselves in the
foot, that is, to load modules which are incompatible to each other. While
module files in principle offer the possibility to specify conflicts and
thereby prevent loading of incompatible modules, all conflicting modules have
to be explicitly listed. For example, the Open\,MPI module built for GCC may
specify that it is incompatible with modules providing Intel or Clang
compilers. However, this means that these conflict specifications have to be
adjusted once an additional compiler (e.g., PGI) gets installed on the
system---which is clearly a maintenance nightmare from the perspective of a
system administrator.

\remark{briefly explain concept of module files, flat naming scheme +
variations (e.g. categorized, per toolchain, \ldots)}

\subsubsection{Modules tool}

\paragraph{Environment modules}

In the traditional environment modules
implementation~\cite{environment_modules_paper}, the \texttt{module} command
is implemented as a simple shell function (for Bourne-compatible shells) or
alias (for csh-compatible shells) which evaluates the commands printed by a
helper tool \texttt{modulecmd} to standard output. This helper tool
implements the actual functionality of identifying the requested command,
locating and parsing the corresponding module files, and generating the
commands necessary to modify the user's environment.

Over time, multiple implementations of the \texttt{modulecmd} helper tool
have been developed. The traditional version is written in C, using the Tcl
library to parse and evaluate module files. A second implementation, which
was never packaged as a release and is still marked as experimental by the
authors, is written in Tcl only. For the most part, these two implementations
offer identical functionality, however, they obviously suffer from the usual
problem of keeping the different code bases consistent, which sometimes leads
to subtle effects when switching between them. In addition, there exists a
fork of the Tcl-only implementation which has been heavily adjusted to meet
the requirements of the DEISA (Distributed European Infrastructure for
Supercomputing Applications) project.

\remark{briefly explain Tcl/C and Tcl-only environment module tools}

While all three implementations provide the desired basic functionality, they
are barely maintained and development progresses slowly. For example, there
has been no activity in the (publicly accessible) version control system of
the Tcl-only implementation for about two years. That is, new features such
as improved support for organizing modules in a hierarchical way are very
unlikely to happen any time soon.
\remark{works, but barely maintained, no further development/features, \ldots}

\markus{From what I can see, there are at least active discussions on the
modules-interest mailing list. However, the answers from the maintainers
suggest to me that they have no interest in changing things too much. What is
your impression? I'm also not sure whether we should really write this down
in a paper ;-)}

\markus{One possible reviewer comment may be: Why didn't you contribute a patch to
the existing project rather than reinventing the wheel? Do we have a good
answer to this? Robert, did you actually try to contribute and they rejected
to include the patch?}


\paragraph{Other}

???
\remark{cmod, \ldots}

\subsubsection{Installing scientific software}

???

\remark{manual, in-house scripting, 'Jim', little to no collaboration across
HPC sites (a few exceptions!)}

\markus{Does it make sense to also mention RPM and DEB packages? For a
regular software install, the downside is that only one version can be
available. But of course packaging systems can be combined with our proposed
approach to roll out the software on a bunch of nodes (see TACC).}

\subsection{Shortcomings \& unresolved issues}

???
\remark{manual creating of module files (consistency issues), repetitive \&
error-prone work of installing scientific software, \ldots}
